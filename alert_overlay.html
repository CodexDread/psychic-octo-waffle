<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="Cache-Control" content="no-cache">
        <title></title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
        
        <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/@streamerbot/client/dist/streamerbot-client.js"></script>
        <script src="https://unpkg.com/three@0.155.0/build/three.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js"></script>
       
        <script src="./utils/overlay.utils.js"></script>
        <script src="./utils/overlay.sb.js"></script>
        <link rel="stylesheet" href="./utils/overlay.stylesheet.css"></link>
        <script src="./utils/overlay.animations.js"></script>
    </head>
    <body>
        <div id="sb-status">[ no active streamer.bot instances ]</div>
        <div id="stack"></div>

        <script type="text/javascript">

            const cfg = window.overlayConfig;
            const alerts = cfg?.ALERTS || {};
            const { DistortionMask, MosaicFallback, createMask } = window.overlayFX;

            const { Bus, clamp, mmss } = window.overlayKit; // from utils
            const el = {
                stack: document.getElementById('stack'),
                sbBadge: document.getElementById('sb-status')
            };

            overlayKit.Bus.on('sb:connected', (e)=> {
                const ok = !!(e.detail?.ok);
                el.sbBadge.hidden = ok;
            });

            const active = []; //Active que
            const pending = []; //Pending que

            // late-load check for sb connection
            let gotReply = false;
            Bus.addEventListener('sb:connected', ()=> { gotReply = true });
            Bus.emit('sb:ping');
            setTimeout(()=> { if (!gotReply) el.sbBadge.hidden = false; }, 1200);

            function oneOf(...opts) { return opts[Math.floor(Math.random() * opts.length)]; }
            
            const TXT = { // Text fillers for alerts
                FOLLOW: (u) => oneOf(
                    `Uplink handshake complete: ${u}`,
                    `Node joined mesh: ${u}  // NH:SYNC`,
                    `Access key registered → ${u}`
                ),

                PRIME: (u) => oneOf(
                    `Prime route established: ${u}`,
                    `Renova.priority grant: ${u}`,
                    `Crown key validated (Prime): ${u}`
                ),

                TIER: (u, t) => oneOf(
                    `Service level ${t} online: ${u}`,
                    `Ionforge retainer ${t} secured: ${u}`,
                    `Contract ${t} executed → ${u}`
                ),

                RESUB: (u, m) => oneOf(
                    `Continuity ${m} cycles: ${u}`,
                    `Contract rollover (${m}m): ${u}`,
                    `SLA renewal ${m}m — ${u}`
                ),

                GIFT: (u, c) => oneOf(
                    `Bulk keys dispatched ×${c} by ${u}`,
                    `Orichal airdrop ×${c} — issuer: ${u}`,
                    `Grant bundle ×${c} in ${u}’s name`
                ),

                CHEER: (u, b) => oneOf(
                    `Signal boost +${b}μ: ${u}`,
                    `Ion credits +${b} issued to channel`,
                    `Tipstream +${b} — from ${u}`
                ),

                RAID: (u, v) => oneOf(
                    `Allied convoy +${v} — ${u}`,
                    `Incursion detected +${v}: ${u}`,
                    `Backtrace linked: ${u} leading +${v}`
                ),

                ADRUN: () => oneOf(
                    `Commercial uplink engaged  // DataDyne`,
                    `Sponsor relay: line open`,
                    `Ad channel: sync & broadcast`,
                    `DataDyne interlude: standby`
                ),
            };

            class makeAlertCard {
                constructor(payload) {
                    this.payload = payload || {};
                    const d = this.payload;

                    this.el = document.createElement('div');
                    this.el.className = 'card';
                    this.el.setAttribute('data-ui', 'card');
                    this.el.innerHTML = `
                        <div class="chip">[ ${d.type} ]</div>
                        <div class="row"></div>
                        <div class="row"><div class="meta"></div></div>
                        <div class="row"><div class="note"></div></div>
                        <div class="bar"></div>
                       <div class="row"><div class="chk" data-fx="scramble" data-fx-opts='{"loop":true,"text":"lore = N U L L H O W L"}'>lore = N U L L H O W L</div></div>
                    `;
                    this.chip = this.el.querySelector('.chip');
                    this.meta = this.el.querySelector('.meta');
                    this.note = this.el.querySelector('.note');
                    this.bar = this.el.querySelector('.bar');
                    this.chk = this.el.querySelector('.chk');

                    //mask
                    const { mask, fallback } = createMask(this.el);
                    this.mask = mask;
                    this.fallback = fallback;

                    this._fill();
                }
                
                _fill() {
                    const d = this.payload, K = d.type;

                    //bar layout
                    const b = this.bar;

                    b.style.left = '0';
                    b.style.top = '0';
                    b.style.right = '0';
                    b.style.height = '10px';

                    if (K === 'AdRun') {
                        this.meta.textContent = TXT.ADRUN();

                        //const len = clamp(Math.round(d.length || 0));
                        const len = clamp(Math.round(Number(d.length) || 0), 0, 3600);
                        const adEnd = Date.now() + len * 1000;
                        this.note.textContent = `midroll ends in ${mmss(len)}`;
                        const _t = setInterval(()=> {
                            const left = Math.max(0, Math.ceil((adEnd - Date.now()) / 1000));
                            this.note.textContent = `midroll ends in ${mmss(left)}`;
                            if (left <= 0) clearInterval(_t);
                        }, 1000);
                        this._durationMs = len * 1000;
                        this._isAd = true;
                        console.log(d.length, len , this._durationMs);
                    } else {

                        this._isAd = false;

                        this.chip.textContent = `[ ${d.type} ]`;
                        this.meta.textContent = d.meta;
                        this.note.textContent = d.note;

                        this._durationMs = alerts?.ALERT_LIFETIME_MS;
                    }
                }

                async appear() {
                    anime.set(this.el, { opacity: 1, translateY: 0 });
                    try {
                        await this.mask.appear(650);
                        this.mask.hide();
                    } catch (e) {
                        if (!this.fallback) this.fallback = new MosaicFallback(this.el);
                        await this.fallback.appear(650);
                        this.fallback.hide();
                    }
                }

                async disappear() {
                    //anime.set(this.el, { opacity: 0, translateY: 8 });
                    try {
                        await (this.mask ? this.mask.disappear(520) : Promise.reject('NO_WEBGL'));
                        this.mask && this.mask.hide();
                    } catch (e) {
                        if (!this.fallback) this.fallback = new MosaicFallback(this.el);
                        await this.fallback.disappear(520);
                        this.fallback.hide();
                    }
                    anime.set(this.el, { opacity: 0, translateY: 8 });
                }

                async run() {
                    await this.appear();

                    //bar animation
                    if (this._isAd) {
                        anime.set(this.bar, { width: '100%' });
                        await (anime({
                            targets: this.bar, width: [ '100%', '0%'], duration: this._durationMs, easing: 'linear',
                            update: (a)=> {
                                const remain = Math.ceil(this._durationMs / 1000 - (a.progress / 100) * (this._durationMs / 1000));

                                this.note.textContent = `midroll ends in ${mmss(remain)}`;
                            }
                        }).finished || Promise.resolve());
                    } else {
                        anime.set(this.bar, { width: '100%' });
                        await (anime({
                            targets: this.bar, width: [ '100%', '0%' ], duration: this._durationMs, easing: 'linear'
                        }).finished || Promise.resolve());
                    }

                    await this.disappear();
                }

                destroy() {
                    this.mask && this.mask.destroy();
                    this.el.remove();
                }
            }

            //Stack manager
            function pushAlertCard(card) {
                if (active.length < alerts?.MAX_STACK) { showCard(card); } else { pending.push(card); }
            }

            async function showCard(card) {
                el.stack.appendChild(card.el);
                active.push(card);

                try { await card.run(); } finally { 
                    const i = active.indexOf(card); if (i >= 0) active.splice(i, 1);
                    card.destroy();

                    if (pending.length) {
                        showCard(pending.shift());
                    }
                }
            }

            function metaBuilder(d) {
                const type = d?.type;

                const u = d?.user;
                const t = d?.tier;
                const c = d?.count;
                const v = d?.viewers;
                const m = d?.months;

                switch (type) {
                    case "Follow":
                        return TXT.FOLLOW(u);
                        break;
                    case "Sub":
                        if (t === "Prime") { return TXT.PRIME(u); } else { return TXT.TIER(u, t); };
                        break;
                    case "ReSub":
                        return TXT.RESUB(u, m);
                        break;
                    case "Gift":
                        return TXT.GIFT(u, c);
                        break;
                    case "Cheer":
                        return TXT.CHEER(u, c);
                        break;
                    case "Raid":
                        return TXT.RAID(u, v);
                        break;
                    case "AdRun":
                        return TXT.ADRUN();
                        break;
                }
            };

            const stripNullStrings = (value) => {
                if (value === 'null') return '';        // or '' if you prefer
                if (!value || typeof value !== 'object') return value;
                if (Array.isArray(value)) return value.map(stripNullStrings);
                return Object.fromEntries(
                    Object.entries(value).map(([key, val]) => [key, stripNullStrings(val)])
                );
            };

            //Event Sub Listeners
            Bus.addEventListener('alerts:sub', (e)=> {
                const raw = e.detail ?? {};
                const d = stripNullStrings(raw);

                const type = d.type ?? 'ALERT TYPE VALUE';
                const meta = metaBuilder(d);
                const note = d.message ? `${String(d.message)}`: '';

                pushAlertCard( new makeAlertCard({ type, meta, note}));
            })

            Bus.addEventListener('alerts:resub', (e)=> {
                const d = stripNullStrings(e.detail ?? {});

                const type = d.type ?? 'ALERT TYPE VALUE';
                const meta = metaBuilder(d);
                const note = d.message ? `${String(d.message)}` : '';

                pushAlertCard( new makeAlertCard({ type, meta, note }));
            })

            Bus.addEventListener('alerts:follow', (e)=> {
                const d = stripNullStrings(e.detail ?? {});

                const type = d.type ?? 'ALERT TYPE VALUE';
                const meta = metaBuilder(d);

                pushAlertCard( new makeAlertCard({ type, meta }));
            })

            Bus.addEventListener('alerts:raid', (e)=> {
                const d = stripNullStrings(e.detail ?? {});

                const type = d.type ?? 'ALERT TYPE VALUE';
                const meta = metaBuilder(d);

                pushAlertCard( new makeAlertCard({ type, meta }));
            })

            Bus.addEventListener('alerts:giftsub', (e)=> {
                const d = stripNullStrings(e.detail ?? {});

                const type = d.type ?? 'ALERT TYPE VALUE';
                const meta = metaBuilder(d);

                pushAlertCard( new makeAlertCard({ type, meta }));
            })

            Bus.addEventListener('alerts:bits', (e)=> {
                const d = stripNullStrings(e.detail ?? {});

                const type = d.type ?? 'ALERT TYPE VALUE';
                const meta = metaBuilder(d);
                const note = d.message ? `${String(d.message)}` : '';

                pushAlertCard( new makeAlertCard({ type, meta, note }));
            })

            Bus.addEventListener('ads:start', (e)=> {
                const d = stripNullStrings(e.detail ?? {});

                const type = d.type ?? 'ALERT TYPE VALUE';
                const meta = metaBuilder(d);
                
                pushAlertCard( new makeAlertCard({ type, meta, length: d.length }));
            })
        </script>
    </body>
</html>