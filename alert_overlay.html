<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="Cache-Control" content="no-cache">
        <title></title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
        
        <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/@streamerbot/client/dist/streamerbot-client.js"></script>
        <script src="https://unpkg.com/three@0.155.0/build/three.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js"></script>
       
        <script src="./utils/overlay.utils.js"></script>
        <script src="./utils/overlay.sb.js"></script>
        <link rel="stylesheet" href="./utils/overlay.stylesheet.css"></link>
        <script src="./utils/overlay.animations.js"></script>
    </head>
    <body>
        <div id="sb-status">[ no active streamer.bot instances ]</div>
        <div id="stack"></div>

        <script type="text/javascript">

            const cfg = window.overlayConfig;
            const alerts = cfg?.ALERTS || {};

            const { Bus, clamp, mmss } = window.overlayKit; // from utils
            const el = {
                stack: document.getElementById('stack'),
                sbBadge: document.getElementById('sb-status')
            };

            overlayKit.Bus.on('sb:connected', (e)=> {
                const ok = !!(e.detail?.ok);
                el.sbBadge.hidden = ok;
            });

            const active = []; //Active que
            const pending = []; //Pending que

            // late-load check for sb connection
            let gotReply = false;
            Bus.addEventListener('sb:connected', ()=> { gotReply = true });
            Bus.emit('sb:ping');
            setTimeout(()=> { if (!gotReply) el.sbBadge.hidden = false; }, 1200);

            function oneOf(...opts) { return opts[Math.floor(Math.random() * opts.length)]; }
            
            const TXT = { // Text fillers for alerts
                FOLLOW: (u) => oneOf(
                    `Uplink handshake complete: ${u}`,
                    `Node joined mesh: ${u}  // NH:SYNC`,
                    `Access key registered → ${u}`
                ),

                PRIME: (u) => oneOf(
                    `Prime route established: ${u}`,
                    `Renova.priority grant: ${u}`,
                    `Crown key validated (Prime): ${u}`
                ),

                TIER: (u, t) => oneOf(
                    `Service level ${t} online: ${u}`,
                    `Ionforge retainer ${t} secured: ${u}`,
                    `Contract ${t} executed → ${u}`
                ),

                RESUB: (u, m) => oneOf(
                    `Continuity ${m} cycles: ${u}`,
                    `Contract rollover (${m}m): ${u}`,
                    `SLA renewal ${m}m — ${u}`
                ),

                GIFT: (u, c) => oneOf(
                    `Bulk keys dispatched ×${c} by ${u}`,
                    `Orichal airdrop ×${c} — issuer: ${u}`,
                    `Grant bundle ×${c} in ${u}’s name`
                ),

                CHEER: (u, b) => oneOf(
                    `Signal boost +${b}μ: ${u}`,
                    `Ion credits +${b} issued to channel`,
                    `Tipstream +${b} — from ${u}`
                ),

                RAID: (u, v) => oneOf(
                    `Allied convoy +${v} — ${u}`,
                    `Incursion detected +${v}: ${u}`,
                    `Backtrace linked: ${u} leading +${v}`
                ),

                ADRUN: () => oneOf(
                    `Commercial uplink engaged  // DataDyne`,
                    `Sponsor relay: line open`,
                    `Ad channel: sync & broadcast`,
                    `DataDyne interlude: standby`
                ),
            };

            class DistortionMask {
                constructor(cardEl) {
                this.host = document.createElement('div');
                this.host.className = 'glfx';
                cardEl.appendChild(this.host);

                this.enabled = true;
                try {
                    this.renderer = new THREE.WebGLRenderer({ alpha: true, antialias: false, powerPreference: 'high-performance' });
                    const ctx = this.renderer.getContext();
                    if (!ctx) throw new Error('No WebGL');
                } catch (e) {
                    this.enabled = false;
                    this.host.style.display = 'none';
                    return;
                }
                this.scene = new THREE.Scene();
                this.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, -1, 1);
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                this.host.appendChild(this.renderer.domElement);

                const geo = new THREE.PlaneGeometry(2, 2);
                this.uniforms = {
                    uTime: { value: 0 },
                    uLevel: { value: 1 }, // 1 cover, 0 reveal
                    uGrid: { value: new THREE.Vector2(54, 7) },
                    uSoft: { value: 0.12 },
                    uJitter: { value: 0.015 }
                };
                const vert = `precision highp float; varying vec2 vUv; void main(){ vUv=uv; gl_Position=vec4(position,1.0);} `;
                const frag = `
                precision highp float; varying vec2 vUv;
                uniform float uTime, uLevel, uSoft, uJitter; uniform vec2 uGrid;
                float hash21(vec2 p){ p=fract(p*vec2(123.34,345.45)); p+=dot(p,p+34.345); return fract(p.x*p.y); }
                void main(){
                    vec2 gridUV=vUv*uGrid; vec2 id=floor(gridUV); vec2 uv=fract(gridUV);
                    float rnd=hash21(id);
                    vec2 jit=(vec2(hash21(id+7.1),hash21(id+3.7))-0.5)*uJitter*(1.0+0.75*sin(uTime*3.0+rnd*6.2831));
                    vec2 cu=clamp(uv+jit,0.0,1.0);
                    float keep=step(rnd,uLevel);
                    vec2 edge=smoothstep(0.0,uSoft,cu)*smoothstep(0.0,uSoft,1.0-cu);
                    float alpha=keep*edge.x*edge.y*(0.9+0.1*sin(uTime*20.0+rnd*12.0));
                    gl_FragColor=vec4(0.0,0.0,0.0,alpha);
                }`;
                this.mat = new THREE.ShaderMaterial({ uniforms: this.uniforms, vertexShader: vert, fragmentShader: frag, transparent: true });
                this.mesh = new THREE.Mesh(geo, this.mat);
                this.scene.add(this.mesh);

                this._time = 0; this._anim = null; this._running = true;
                const ro = new ResizeObserver(() => this.resize());
                ro.observe(cardEl); this._ro = ro;
                this.resize(); this._loop();
                }
                resize() {
                if (!this.enabled) return;
                const w = this.host.clientWidth || this.host.parentElement.clientWidth || 1;
                const h = this.host.clientHeight || this.host.parentElement.clientHeight || 1;
                this.renderer.setSize(w, h, false);
                }
                _loop() {
                if (!this.enabled || !this._running) return;
                this._time += 0.016;
                this.uniforms.uTime.value = this._time;
                this.renderer.render(this.scene, this.camera);
                requestAnimationFrame(() => this._loop());
                }
                appear(ms) {
                if (!this.enabled) return Promise.reject('NO_WEBGL');
                if (this._anim) this._anim.pause();
                this.uniforms.uLevel.value = 1.0;
                this.host.style.display = 'block';
                this._anim = anime({ targets: this.uniforms.uLevel, value: 0, duration: ms, easing: 'easeOutCubic' });
                return this._anim.finished || Promise.resolve();
                }
                disappear(ms) {
                if (!this.enabled) return Promise.reject('NO_WEBGL');
                if (this._anim) this._anim.pause();
                this.uniforms.uLevel.value = 0.0;
                this.host.style.display = 'block';
                this._anim = anime({ targets: this.uniforms.uLevel, value: 1, duration: ms, easing: 'easeInCubic' });
                return this._anim.finished || Promise.resolve();
                }
                hide() { this.host.style.display = 'none'; }
                destroy() { this._running = false; this._ro && this._ro.disconnect(); this.renderer && this.renderer.dispose(); this.host.remove(); }
            }

            /* Fallback mosaic if no WebGL */
            class MosaicFallback {
                constructor(cardEl) {
                this.host = document.createElement('div'); this.host.className = 'maskFallback'; cardEl.appendChild(this.host);
                this.cells = []; this.cols = 38; this.rows = 18; this._build();
                }
                _build() {
                this.host.innerHTML = ''; this.cells.length = 0;
                const cw = 100 / this.cols, ch = 100 / this.rows;
                for (let r = 0; r < this.rows; r++) {
                    for (let c = 0; c < this.cols; c++) {
                    const d = document.createElement('div'); d.className = 'cell';
                    d.style.left = `${c * cw}%`; d.style.top = `${r * ch}%`; d.style.width = `${cw + 0.2}%`; d.style.height = `${ch + 0.3}%`;
                    d.style.opacity = 1; this.host.appendChild(d); this.cells.push(d);
                    }
                }
                }
                appear(ms) {
                anime.set(this.cells, { opacity: 1 }); this.host.style.display = 'block';
                const a = anime({ targets: this.cells, opacity: [{ value: 0, duration: ms, easing: 'easeOutQuad' }], delay: anime.stagger(8, { grid: [this.rows, this.cols], from: 'center' }) });
                return a.finished || Promise.resolve();
                }
                disappear(ms) {
                anime.set(this.cells, { opacity: 0 }); this.host.style.display = 'block';
                const a = anime({ targets: this.cells, opacity: [{ value: 1, duration: ms, easing: 'easeInQuad' }], delay: anime.stagger(6, { grid: [this.rows, this.cols], from: 'center' }) });
                return a.finished || Promise.resolve();
                }
                hide() { this.host.style.display = 'none'; }
                destroy() { this.host.remove(); }
            }

            class makeAlertCard {
                constructor(payload) {
                    this.payload = payload || {};
                    const d = this.payload;

                    this.el = document.createElement('div');
                    this.el.className = 'card';
                    this.el.setAttribute('data-ui', 'card');
                    this.el.innerHTML = `
                        <div class="chip">[ ${d.type} ]</div>
                        <div class="row"></div>
                        <div class="row"><div class="meta"></div></div>
                        <div class="row"><div class="note"></div></div>
                        <div class="bar"></div>
                        <div class="chk">chk = N U L L H O W L</div>
                    `;
                    this.chip = this.el.querySelector('.chip');
                    this.meta = this.el.querySelector('.meta');
                    this.note = this.el.querySelector('.note');
                    this.bar = this.el.querySelector('.bar');
                    this.chk = this.el.querySelector('.chk');

                    //mask
                    this.mask = new DistortionMask(this.el);
                    if (!this.mask.enabled) this.fallback = new MosaicFallback(this.el);

                    this._fill();
                }
                
                _fill() {
                    const d = this.payload, K = d.type;
                    if (K === 'AdRun') {
                        this.meta.textContent = TXT.ADRUN();

                        const len = clamp(Math.round(d.length || 0));
                        const adEnd = Date.now() + len * 1000;
                        this.note.textContent = `midroll ends in ${mmss(len)}`;
                        const _t = setInterval(()=> {
                            const left = Math.max(0, Math.ceil((adEnd - Date.now()) / 1000));
                            this.note.textContent = `midroll ends in ${mmss(left)}`;
                            if (left <= 0) clearInterval(_t);
                        }, 1000);

                        this._durationMs = len * 1000;
                        this._isAd = true;
                    } else {

                        this._isAd = false;

                        this.chip.textContent = d.type;
                        this.meta.textContent = d.meta;
                        this.note.textContent = d.note;

                        //bar layout
                        const b = this.bar;

                        b.style.left = '0';
                        b.style.top = '0';
                        b.style.right = '0';
                        b.style.height = '10px';

                        this._durationMs = alerts?.ALERT_LIFETIME_MS;
                    }
                }

                async appear() {
                    anime.set(this.el, { opacity: 1, translateY: 0 });
                    try {
                        await this.mask.appear(650);
                        this.mask.hide();
                    } catch (e) {
                        if (!this.fallback) this.fallback = new MosaicFallback(this.el);
                        await this.fallback.appear(650);
                        this.fallback.hide();
                    }
                }

                async disappear() {
                    //anime.set(this.el, { opacity: 0, translateY: 8 });
                    try {
                        await (this.mask ? this.mask.disappear(520) : Promise.reject('NO_WEBGL'));
                        this.mask && this.mask.hide();
                    } catch (e) {
                        if (!this.fallback) this.fallback = new MosaicFallback(this.el);
                        await this.fallback.disappear(520);
                        this.fallback.hide();
                    }
                    anime.set(this.el, { opacity: 0, translateY: 8 });
                }

                async run() {
                    await this.appear();
                    //start text scramble

                    //bar animation
                    if (this._isAd) {
                        anime.set(this.bar, { width: '100%' });
                        await (anime({
                            targets: this.bar, width: [ '100%', '0%'], duration: this._durationMs, easing: 'linear',
                            update: (a)=> {
                                const remain = Math.ceil(this._durationMs / 1000 - (a.progress / 100) * (this._durationMs / 1000));

                                this.note.textContent = `midroll ends in ${mmss(remain)}`;
                            }
                        }).finished || Promise.resolve());
                    } else {
                        anime.set(this.bar, { width: '100%' });
                        await (anime({
                            targets: this.bar, width: [ '100%', '0%' ], duration: this._durationMs, easing: 'linear'
                        }).finished || Promise.resolve());
                    }

                    //stop scramble then disapear
                    await this.disappear();
                }

                destroy() {
                    this.mask && this.mask.destroy();
                    this.el.remove();
                }
            }

            //Stack manager
            function pushAlertCard(card) {
                if (active.length < alerts?.MAX_STACK) { showCard(card); } else { pending.push(card); }
            }

            async function showCard(card) {
                el.stack.appendChild(card.el);
                active.push(card);

                try { await card.run(); } finally { 
                    const i = active.indexOf(card); if (i >= 0) active.splice(i, 1);
                    card.destroy();

                    if (pending.length) {
                        showCard(pending.shift());
                    }
                }
            }

            function metaBuilder(d) {
                const type = d?.type;

                const u = d?.user;
                const t = d?.tier;
                const c = d?.count;
                const v = d?.viewers;
                const m = d?.months;

                switch (type) {
                    case "Follow":
                        return TXT.FOLLOW(u);
                        break;
                    case "Sub":
                        if (t === "Prime") { return TXT.PRIME(u); } else { return TXT.TIER(u, t); };
                        break;
                    case "ReSub":
                        return TXT.RESUB(u, m);
                        break;
                    case "Gift":
                        return TXT.GIFT(u, c);
                        break;
                    case "Cheer":
                        return TXT.CHEER(u, c);
                        break;
                    case "Raid":
                        return TXT.RAID(u, v);
                        break;
                }
            };

            //Event Sub Listeners
            Bus.addEventListener('alerts:sub', (e)=> {
                const d = e.detail ?? {};

                const type = d.type ?? 'ALERT TYPE VALUE';
                const meta = metaBuilder(d);
                const note = d.message ? `${String(d.message)}` : 'USER MESSAGE VALUE';

                pushAlertCard( new makeAlertCard({ type, meta, note}));
            })
        </script>
    </body>
</html>