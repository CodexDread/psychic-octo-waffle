<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="Cache-Control" content="no-cache">
        <title></title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
        
        <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/@streamerbot/client/dist/streamerbot-client.js"></script>
        <script src="https://unpkg.com/three@0.155.0/build/three.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js"></script>
       
        <script src="./utils/overlay.utils.js"></script>
        <script src="./utils/overlay.sb.js"></script>
        <link rel="stylesheet" href="./utils/overlay.stylesheet.css"></link>
        <script src="./utils/overlay.animations.js"></script>
    </head>
    <body>
        <div id="sb-status">[ no active streamer.bot instances ]</div>
        <div id="stack"></div>

        <script type="text/javascript">

            const cfg = window.overlayConfig;
            const alerts = cfg?.ALERTS || {};

            const { Bus, clamp, mmss } = window.overlayKit; // from utils
            const el = {
                stack: document.getElementById('stack'),
                sbBadge: document.getElementById('sb-status')
            };

            overlayKit.Bus.on('sb:connected', (e)=> {
                const ok = !!(e.detail?.ok);
                el.sbBadge.hidden = ok;
            });

            const active = []; //Active que
            const pending = []; //Pending que

            // late-load check for sb connection
            let gotReply = false;
            Bus.addEventListener('sb:connected', ()=> { gotReply = true });
            Bus.emit('sb:ping');
            setTimeout(()=> { if (!gotReply) el.sbBadge.hidden = false; }, 1200);

            function oneOf(...opts) { return opts[Math.floor(Math.random() * opts.length)]; }
            
            const TXT = { // Text fillers for alerts
                FOLLOW: (u) => oneOf(
                    `Uplink handshake complete: ${u}`,
                    `Node joined mesh: ${u}  // NH:SYNC`,
                    `Access key registered → ${u}`
                ),

                PRIME: (u) => oneOf(
                    `Prime route established: ${u}`,
                    `Renova.priority grant: ${u}`,
                    `Crown key validated (Prime): ${u}`
                ),

                TIER: (u, t) => oneOf(
                    `Service level ${t} online: ${u}`,
                    `Ionforge retainer ${t} secured: ${u}`,
                    `Contract ${t} executed → ${u}`
                ),

                RESUB: (u, m) => oneOf(
                    `Continuity ${m} cycles: ${u}`,
                    `Contract rollover (${m}m): ${u}`,
                    `SLA renewal ${m}m — ${u}`
                ),

                GIFT: (u, c) => oneOf(
                    `Bulk keys dispatched ×${c} by ${u}`,
                    `Orichal airdrop ×${c} — issuer: ${u}`,
                    `Grant bundle ×${c} in ${u}’s name`
                ),

                CHEER: (u, b) => oneOf(
                    `Signal boost +${b}μ: ${u}`,
                    `Ion credits +${b} issued to channel`,
                    `Tipstream +${b} — from ${u}`
                ),

                RAID: (u, v) => oneOf(
                    `Allied convoy +${v} — ${u}`,
                    `Incursion detected +${v}: ${u}`,
                    `Backtrace linked: ${u} leading +${v}`
                ),

                ADRUN: () => oneOf(
                    `Commercial uplink engaged  // DataDyne`,
                    `Sponsor relay: line open`,
                    `Ad channel: sync & broadcast`,
                    `DataDyne interlude: standby`
                ),
            };

            class makeAlertCard {
                constructor(payload) {
                    this.payload = payload || {};
                    const d = this.payload;

                    this.el = document.createElement('div');
                    this.el.className = 'card';
                    this.el.innerHTML = `
                        <div class="chip">[ ${d.title} ]</div>
                        <div class="row"></div>
                        <div class="row"><div class="meta"></div></div>
                        <div class="row"><div class="note"></div></div>
                        <div class="bar"></div>
                        <div class="chk">chk = N U L L H O W L</div>
                    `;
                    this.chip = this.el.querySelector('.chip');
                    this.meta = this.el.querySelector('.meta');
                    this.note = this.el.querySelector('.note');
                    this.bar = this.el.querySelector('.bar');
                    this.chk = this.el.querySelector('.chk');

                    this._fill();
                }
                
                _fill() {
                    const d = this.payload, K = d.title;
                    if (K === 'AdRun') {
                        this.meta.textContent = TXT.ADRUN();

                        const len = clamp(Math.round(d.length || 0));
                        const adEnd = Date.now() + len * 1000;
                        this.note.textContent = `midroll ends in ${mmss(len)}`;
                        const _t = setInterval(()=> {
                            const left = Math.max(0, Math.ceil((adEnd - Date.now()) / 1000));
                            this.note.textContent = `midroll ends in ${mmss(left)}`;
                            if (left <= 0) clearInterval(_t);
                        }, 1000);

                        this._durationMs = len * 1000;
                        this._isAd = true;
                    } else {

                        this._isAd = false;
                    }
                }

                async appear() {
                    anime.set(this.el, { opactiy: 1, translateY:0 });
                }

                async disappear() {
                    anime.set(this.el, { opacity: 0, translateY: 8 });
                }

                async run() {
                    await this.appear();
                    //start text scramble

                    //bar animation
                    if (this._isAD) {
                        anime.set(this.bar, { width: '100%' });
                        await (anime({
                            targets: this.bar, width: [ '100%', '0%'], duration: this._durationMs, easing: 'linear',
                            update: (a)=> {
                                const remain = Math.ceil(this._durationMs / 1000 - (a.progress / 100) * (this._durationMs / 1000));

                                this.note.textContent = `midroll ends in ${mmss(remain)}`;
                            }
                        }).finished || Promise.resolved());
                    } else {
                        anime.set(this.bar, { width: '100%' });
                        await (anime({
                            targets: this.bar, width: [ '100%', '0%' ], duration: this.durationMs, easing: 'linear'
                        }).finihsed || Promis.resolved());
                    }

                    //stop scramble then disapear
                    await this.disappear();
                }

                destroy() {
                    this.el.remove();
                }
            }

            //Stack manager
            function pushAlertCard(card) {
                if (active.length < alerts?.MAX_STACK) { showCard(card); } else { pending.push(card); }
            }

            async function showCard(card) {
                el.stack.appendChild(card.el);
                active.push(card);

                try { await card.run(); } finally { 
                    const i = active.indexOf(card); if (i >= 0) active.splice(i, i);
                    card.destroy();

                    if (pending.length) {
                        showCard(pending.shift());
                    }
                }
            }

            //Event Sub Listeners
            Bus.addEventListener('alerts:sub', (e)=> {
                const d = e.detail ?? {};

                const title = d.title ?? 'NULL VALUE';
                const meta = metaBuilder(d);
                const note = d.message ? `${String(d.message)}` : 'NULL VALUE';

                pushAlertCard( new makeAlertCard({ title, meta, note}));
            })
        </script>
    </body>
</html>